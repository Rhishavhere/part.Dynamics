<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Gravity Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100; /* Ensure info text is above the canvas */
        }
    </style>
</head>
<body>
    <div id="info">Star Gravity Simulation | Drag to rotate, Scroll to zoom, Right-click drag to pan</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let star, starMass;
        let particlesGeometry, particlesMaterial, particleSystem;
        let particlePositions, particleVelocities, particleColors, particleAccelerations; // Buffers and simulation arrays

        // --- Simulation Constants ---
        const NUM_PARTICLES = 100000; // Number of particles
        const G = 1.5;             // Gravitational constant (tuned for visual appeal)
        const TIME_STEP = 0.01;    // Simulation time step
        const SOFTENING_FACTOR_SQ = 5; // Softening factor squared
        const INITIAL_SPREAD_RADIUS = 60; // How spread out the particles start
        const MIN_ORBIT_RADIUS = 10; // Minimum distance from star center
        const STAR_MASS = 1000;     // Mass of the central star
        const PARTICLE_MASS = 0.1;  // Mass of each particle (assumed uniform)
        const PARTICLE_SIZE = 0.3;  // Visual size of particles

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = INITIAL_SPREAD_RADIUS * 1.8; // Start zoomed out

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting (less critical for PointsMaterial/BasicMaterial star, but good to have)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1.0, INITIAL_SPREAD_RADIUS * 3);
            pointLight.position.set(0, 0, 0); // Light emanates from the star
            scene.add(pointLight);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 1000;

            // Background (Space Skybox)
            // const loader = new THREE.CubeTextureLoader();
            // const texture = loader.load([
            //     'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_px.jpg', // Right
            //     'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nx.jpg', // Left
            //     'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_py.jpg', // Top
            //     'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_ny.jpg', // Bottom
            //     'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_pz.jpg', // Front
            //     'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nz.jpg'  // Back
            // ]);
            // texture.encoding = THREE.sRGBEncoding;
            // scene.background = texture;

            // Create Star and Particles
            createStarAndParticles();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Create Central Star and Particle System ---
        function createStarAndParticles() {
            // Create Star Mesh
            starMass = STAR_MASS;
            const starGeometry = new THREE.SphereGeometry(2, 32, 24); // Size of the star visually
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa }); // Simple bright yellow
            star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.set(0, 0, 0); // Star is at the origin
            scene.add(star);

            // Initialize Particle Data Arrays
            particlePositions = new Float32Array(NUM_PARTICLES * 3);
            particleVelocities = new Array(NUM_PARTICLES).fill(null).map(() => new THREE.Vector3());
            particleColors = new Float32Array(NUM_PARTICLES * 3);
            particleAccelerations = new Array(NUM_PARTICLES).fill(null).map(() => new THREE.Vector3()); // For storing calculated acceleration

            const color = new THREE.Color();

            // Initialize each particle
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const i3 = i * 3;

                // Initial Position (random point in a spherical shell)
                let pos;
                let radiusSq;
                do {
                    pos = new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5),
                        (Math.random() - 0.5)
                    ).normalize().multiplyScalar(MIN_ORBIT_RADIUS + Math.random() * (INITIAL_SPREAD_RADIUS - MIN_ORBIT_RADIUS));
                    radiusSq = pos.lengthSq();
                } while (radiusSq < MIN_ORBIT_RADIUS * MIN_ORBIT_RADIUS); // Ensure not inside min radius

                particlePositions[i3 + 0] = pos.x;
                particlePositions[i3 + 1] = pos.y;
                particlePositions[i3 + 2] = pos.z;

                // Initial Velocity (tangential for circular orbit + some randomness)
                const radius = Math.sqrt(radiusSq);
                const orbitalSpeed = Math.sqrt((G * starMass) / radius); // Speed for circular orbit
                const tangent = new THREE.Vector3(-pos.y, pos.x, 0).normalize(); // Simple tangent in xy plane
                // Adjust tangent if pos is along z-axis? For simplicity, keep it basic.
                // A more robust tangent: cross product of position and up vector (e.g., 0,1,0)
                 const robustTangent = new THREE.Vector3().crossVectors(pos, new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5)).normalize();


                particleVelocities[i].copy(robustTangent)
                                     .multiplyScalar(orbitalSpeed * (0.8 + Math.random() * 0.4)); // Add 20% randomness


                // Initial Color (random hue)
                color.setHSL(Math.random(), 0.7 + Math.random() * 0.2, 0.5 + Math.random() * 0.2);
                particleColors[i3 + 0] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;
            }

            // Create BufferGeometry
            particlesGeometry = new THREE.BufferGeometry();
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            // Create PointsMaterial
            particlesMaterial = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                sizeAttenuation: true, // Points closer are larger
                vertexColors: true,    // Use colors from geometry attribute
                blending: THREE.AdditiveBlending, // Nice effect for bright particles
                transparent: true,
                depthWrite: false // Helps with transparency sorting issues
            });

            // Create Particle System (Points)
            particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particleSystem);
        }


        // --- Physics Calculation (Star-Particle Interaction Only) ---
        function calculateForces() {
            const starPos = star.position; // Star is at origin

            for (let i = 0; i < NUM_PARTICLES; i++) {
                const i3 = i * 3;
                const particlePos = new THREE.Vector3(
                    particlePositions[i3 + 0],
                    particlePositions[i3 + 1],
                    particlePositions[i3 + 2]
                );

                // Vector from particle to star
                const r_vec = new THREE.Vector3().subVectors(starPos, particlePos);

                // Distance squared + softening factor
                const distSq = r_vec.lengthSq() + SOFTENING_FACTOR_SQ;
                const dist = Math.sqrt(distSq);

                // Force magnitude: F = G * M_star * m_particle / (dist^2 + epsilon^2)
                const forceMag = (G * starMass * PARTICLE_MASS) / distSq;

                // Force vector (direction is r_vec normalized)
                const forceVec = r_vec.multiplyScalar(forceMag / dist); // Normalize and scale

                // Acceleration = Force / mass_particle
                particleAccelerations[i].copy(forceVec).divideScalar(PARTICLE_MASS);
            }
        }

        // --- Update Particle Positions (Euler Integration) ---
        function updateParticlePositions() {
            const positions = particlesGeometry.attributes.position.array; // Get direct access to the buffer

            for (let i = 0; i < NUM_PARTICLES; i++) {
                const i3 = i * 3;

                // Update velocity: v = v + a * dt
                particleVelocities[i].add(particleAccelerations[i].clone().multiplyScalar(TIME_STEP));

                // Update position: p = p + v * dt
                positions[i3 + 0] += particleVelocities[i].x * TIME_STEP;
                positions[i3 + 1] += particleVelocities[i].y * TIME_STEP;
                positions[i3 + 2] += particleVelocities[i].z * TIME_STEP;
            }

            // IMPORTANT: Tell Three.js that the position attribute needs to be updated on the GPU
            particlesGeometry.attributes.position.needsUpdate = true;
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Calculate physics
            calculateForces();
            updateParticlePositions();

            // Update controls
            controls.update();

            // Optional: Rotate the particle system slightly for visual effect
            // particleSystem.rotation.y += 0.0001;

            // Render scene
            renderer.render(scene, camera);
        }

        // --- Window Resize Handler ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
         window.onload = () => {
             init();
             animate();
        }

    </script>
</body>
</html>
